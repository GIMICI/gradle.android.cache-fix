import groovy.json.JsonSlurper

plugins {
    id 'groovy'
    id 'java-gradle-plugin'
    id 'maven-publish'
    id 'signing'
    id 'codenarc'
    id 'com.gradle.plugin-publish' version '1.2.0'
    id 'com.github.breadmoirai.github-release' version '2.4.1'
    id 'org.gradle.wrapper-upgrade' version '0.11.1'
}

def releaseVersion = releaseVersion()
def releaseNotes = releaseNotes()
def isCI = (System.getenv('CI') ?: 'false').toBoolean()

group = 'org.gradle.android'
version = releaseVersion
description = 'A Gradle plugin to fix Android caching problems'

repositories {
    google()
    mavenCentral()
}

dependencies {
    def versions = [
        'agp': '7.3.1',
        'sdkBuildTools': '30.0.4',
        'spock': '2.3-groovy-3.0',
    ]

    compileOnly gradleApi()
    compileOnly "com.android.tools.build:gradle:${versions.agp}"
    compileOnly "com.android.tools:common:${versions.sdkBuildTools}"
    compileOnly "com.android.tools:sdk-common:${versions.sdkBuildTools}"
    implementation("com.google.guava:guava:31.1-jre")


    testImplementation gradleTestKit()
    testImplementation "com.android.tools.build:gradle:${versions.agp}"
    testImplementation platform("org.spockframework:spock-bom:${versions.spock}")
    testImplementation("org.spockframework:spock-core") { exclude group: 'org.codehaus.groovy' }
    testImplementation("org.spockframework:spock-junit4") { exclude group: 'org.codehaus.groovy' }
    testImplementation "org.junit.jupiter:junit-jupiter-api"
}

wrapperUpgrade {
    gradle {
        'android-cache-fix-gradle-plugin' {
            repo = 'gradle/android-cache-fix-gradle-plugin'
        }
    }
}

java {
    toolchain {
        // AGP 7+ only supports JDK 11+
        languageVersion = JavaLanguageVersion.of(11)
    }
}

// Main plugin publishing metadata
gradlePlugin {
    website = 'https://github.com/gradle/android-cache-fix-gradle-plugin'
    vcsUrl = 'https://github.com/gradle/android-cache-fix-gradle-plugin'

    plugins {
        androidCacheFixPlugin {
            id = 'org.gradle.android.cache-fix'
            displayName = 'Gradle Android cache fix plugin'
            description = releaseNotes.get()
            implementationClass = 'org.gradle.android.AndroidCacheFixPlugin'
            tags.addAll('android', 'cache', 'fix')
        }
    }
}

// A local repo we publish our library to for testing in order to workaround limitations
// in the TestKit plugin classpath.
def localRepo = file("$buildDir/local-repo")

def isProdPortal = !System.getProperty('gradle.portal.url')
// The legacy groupId gradle.plugin.* is only allowed when the plugin
// has already been published
def pluginGroupId = isCI && isProdPortal ? 'gradle.plugin.org.gradle.android' : project.group
publishing {
    publications {
        pluginMaven(MavenPublication) {
            groupId = pluginGroupId
        }
    }
    repositories {
        maven {
            url = localRepo.toURI()
        }
    }
}

// Configuration common to all test tasks
tasks.withType(Test).configureEach {
    dependsOn publish
    workingDir projectDir
    systemProperty "local.repo", projectDir.toPath().relativize(localRepo.toPath()).toString()
    systemProperty "pluginGroupId", pluginGroupId
    systemProperty "org.gradle.android.cache-fix.version", version
    useJUnitPlatform()
    retry {
        maxRetries = isCI ? 1 : 0
        maxFailures = 20
    }
    predictiveSelection {
        enabled = providers.gradleProperty("isPTSEnabled").map { it != 'false' } .orElse(false)
    }
}

// Generate a test task for each Android version and run the tests annotated with the MultiVersionTest category
def supportedVersions = new JsonSlurper().parse(file('src/main/resources/versions.json')).supportedVersions
supportedVersions.keySet().each { androidVersion ->
    def versionSpecificTest = tasks.register(androidTestTaskName(androidVersion), Test) {
        description = "Runs the multi-version tests for AGP ${androidVersion}"
        group = "verification"

        systemProperty 'org.gradle.android.testVersion', androidVersion
        systemProperty 'org.gradle.android.java_zulu_path', project.providers.environmentVariable('ZULU_JDK').getOrNull()
        systemProperty 'org.gradle.android.java_zulu_alt_path', project.providers.environmentVariable('ZULU_ALT_JDK').getOrNull()

        if (androidVersion >= "8.0.0-alpha10") {
            javaLauncher = javaToolchains.launcherFor {
                languageVersion = JavaLanguageVersion.of(17)
            }
        }
    }

    tasks.named('check').configure {
        dependsOn versionSpecificTest
    }
}

static def androidTestTaskName(String androidVersion) {
    return "testAndroid${normalizeVersion(androidVersion)}"
}

static def normalizeVersion(String version) {
    return version.replaceAll('[.\\-]', '_')
}

// A basic sanity check to run before running all test tasks
tasks.register("sanityCheck") {
    dependsOn tasks.withType(CodeNarc), validatePlugins
}

tasks.withType(ValidatePlugins).configureEach {
    failOnWarning = true
    enableStricterValidation = true
}

signing {
    // Require publications to be signed when :publishPlugins task is included in the TaskGraph
    required { gradle.taskGraph.hasTask(":publishPlugins") }

    useInMemoryPgpKeys(
        providers.environmentVariable("PGP_SIGNING_KEY").orNull,
        providers.environmentVariable("PGP_SIGNING_KEY_PASSPHRASE").orNull
    )
}

githubRelease {
    token = System.getenv("ANDROID_CACHE_FIX_PLUGIN_GIT_TOKEN") ?: ''
    owner = "gradle"
    repo = "android-cache-fix-gradle-plugin"
    releaseName = releaseVersion
    tagName = releaseVersion.map { "v$it" }
    prerelease = false
    overwrite = false
    generateReleaseNotes = false
    body = releaseNotes
    targetCommitish = "main"
}

def createReleaseTag = tasks.register('createReleaseTag', CreateGitTag) {
    // Ensure tag is created only after successful publishing
    mustRunAfter('publishPlugins')
    tagName = githubRelease.tagName.map { it.toString() }
}

tasks.named("githubRelease").configure {
    dependsOn(createReleaseTag)
}

tasks.withType(Sign).configureEach {
    notCompatibleWithConfigurationCache("$name task does not support configuration caching")
}

def releaseVersion() {
    def releaseVersionFile = layout.projectDirectory.file('release/version.txt')
    return providers.fileContents(releaseVersionFile).asText.map { it -> it.trim() }
}

def releaseNotes() {
    def releaseNotesFile = layout.projectDirectory.file('release/changes.md')
    return providers.fileContents(releaseNotesFile).asText.map { it -> it.trim() }
}
